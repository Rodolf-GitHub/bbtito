/**
 * Generated by orval v8.4.2 游꽄
 * Do not edit manually.
 * BBTITO API
 * OpenAPI spec version: 1.0
 */
import type {
  DetailSchema,
  LoginSchema,
  PagedProductoSchema,
  ProductoSchema,
  ProductosApiCreateProductoBody,
  ProductosApiListProductosLoMasActualizadoParams,
  ProductosApiListProductosLoMasBaratoParams,
  ProductosApiListProductosOfertasParams,
  ProductosApiListProductosParaHombreParams,
  ProductosApiListProductosParaMujerParams,
  ProductosApiListProductosParams,
  ProductosApiUpdateProductoBody,
  TokenSchema
} from './schemas';

/**
 * Endpoint para listar todos los productos, con soporte de b칰squeda por nombre.
 * @summary List Productos
 */
export type productosApiListProductosResponse200 = {
  data: PagedProductoSchema
  status: 200
}

export type productosApiListProductosResponseSuccess = (productosApiListProductosResponse200) & {
  headers: Headers;
};
;

export type productosApiListProductosResponse = (productosApiListProductosResponseSuccess)

export const getProductosApiListProductosUrl = (params?: ProductosApiListProductosParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/productos/listar_todos?${stringifiedParams}` : `/api/productos/listar_todos`
}

export const productosApiListProductos = async (params?: ProductosApiListProductosParams, options?: RequestInit): Promise<productosApiListProductosResponse> => {
  
  const res = await fetch(getProductosApiListProductosUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiListProductosResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiListProductosResponse
}
  


/**
 * Endpoint para listar todos los productos en oferta, con soporte de b칰squeda por nombre.
 * @summary List Productos Ofertas
 */
export type productosApiListProductosOfertasResponse200 = {
  data: PagedProductoSchema
  status: 200
}

export type productosApiListProductosOfertasResponseSuccess = (productosApiListProductosOfertasResponse200) & {
  headers: Headers;
};
;

export type productosApiListProductosOfertasResponse = (productosApiListProductosOfertasResponseSuccess)

export const getProductosApiListProductosOfertasUrl = (params?: ProductosApiListProductosOfertasParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/productos/listar_ofertas?${stringifiedParams}` : `/api/productos/listar_ofertas`
}

export const productosApiListProductosOfertas = async (params?: ProductosApiListProductosOfertasParams, options?: RequestInit): Promise<productosApiListProductosOfertasResponse> => {
  
  const res = await fetch(getProductosApiListProductosOfertasUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiListProductosOfertasResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiListProductosOfertasResponse
}
  


/**
 * Endpoint para listar todos los productos para mujer, con soporte de b칰squeda por nombre.
 * @summary List Productos Para Mujer
 */
export type productosApiListProductosParaMujerResponse200 = {
  data: PagedProductoSchema
  status: 200
}

export type productosApiListProductosParaMujerResponseSuccess = (productosApiListProductosParaMujerResponse200) & {
  headers: Headers;
};
;

export type productosApiListProductosParaMujerResponse = (productosApiListProductosParaMujerResponseSuccess)

export const getProductosApiListProductosParaMujerUrl = (params?: ProductosApiListProductosParaMujerParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/productos/listar_para_mujer?${stringifiedParams}` : `/api/productos/listar_para_mujer`
}

export const productosApiListProductosParaMujer = async (params?: ProductosApiListProductosParaMujerParams, options?: RequestInit): Promise<productosApiListProductosParaMujerResponse> => {
  
  const res = await fetch(getProductosApiListProductosParaMujerUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiListProductosParaMujerResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiListProductosParaMujerResponse
}
  


/**
 * Endpoint para listar todos los productos para hombre, con soporte de b칰squeda por nombre.
 * @summary List Productos Para Hombre
 */
export type productosApiListProductosParaHombreResponse200 = {
  data: PagedProductoSchema
  status: 200
}

export type productosApiListProductosParaHombreResponseSuccess = (productosApiListProductosParaHombreResponse200) & {
  headers: Headers;
};
;

export type productosApiListProductosParaHombreResponse = (productosApiListProductosParaHombreResponseSuccess)

export const getProductosApiListProductosParaHombreUrl = (params?: ProductosApiListProductosParaHombreParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/productos/listar_para_hombre?${stringifiedParams}` : `/api/productos/listar_para_hombre`
}

export const productosApiListProductosParaHombre = async (params?: ProductosApiListProductosParaHombreParams, options?: RequestInit): Promise<productosApiListProductosParaHombreResponse> => {
  
  const res = await fetch(getProductosApiListProductosParaHombreUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiListProductosParaHombreResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiListProductosParaHombreResponse
}
  


/**
 * Endpoint para listar los productos m치s actualizados, con soporte de b칰squeda por nombre.
 * @summary List Productos Lo Mas Actualizado
 */
export type productosApiListProductosLoMasActualizadoResponse200 = {
  data: PagedProductoSchema
  status: 200
}

export type productosApiListProductosLoMasActualizadoResponseSuccess = (productosApiListProductosLoMasActualizadoResponse200) & {
  headers: Headers;
};
;

export type productosApiListProductosLoMasActualizadoResponse = (productosApiListProductosLoMasActualizadoResponseSuccess)

export const getProductosApiListProductosLoMasActualizadoUrl = (params?: ProductosApiListProductosLoMasActualizadoParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/productos/lo_mas_actualizado?${stringifiedParams}` : `/api/productos/lo_mas_actualizado`
}

export const productosApiListProductosLoMasActualizado = async (params?: ProductosApiListProductosLoMasActualizadoParams, options?: RequestInit): Promise<productosApiListProductosLoMasActualizadoResponse> => {
  
  const res = await fetch(getProductosApiListProductosLoMasActualizadoUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiListProductosLoMasActualizadoResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiListProductosLoMasActualizadoResponse
}
  


/**
 * Endpoint para listar los productos m치s baratos, con soporte de b칰squeda por nombre.
 * @summary List Productos Lo Mas Barato
 */
export type productosApiListProductosLoMasBaratoResponse200 = {
  data: PagedProductoSchema
  status: 200
}

export type productosApiListProductosLoMasBaratoResponseSuccess = (productosApiListProductosLoMasBaratoResponse200) & {
  headers: Headers;
};
;

export type productosApiListProductosLoMasBaratoResponse = (productosApiListProductosLoMasBaratoResponseSuccess)

export const getProductosApiListProductosLoMasBaratoUrl = (params?: ProductosApiListProductosLoMasBaratoParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/productos/lo_mas_barato?${stringifiedParams}` : `/api/productos/lo_mas_barato`
}

export const productosApiListProductosLoMasBarato = async (params?: ProductosApiListProductosLoMasBaratoParams, options?: RequestInit): Promise<productosApiListProductosLoMasBaratoResponse> => {
  
  const res = await fetch(getProductosApiListProductosLoMasBaratoUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiListProductosLoMasBaratoResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiListProductosLoMasBaratoResponse
}
  


/**
 * Endpoint para crear un nuevo producto. Requiere autenticaci칩n.
 * @summary Create Producto
 */
export type productosApiCreateProductoResponse200 = {
  data: ProductoSchema
  status: 200
}

export type productosApiCreateProductoResponseSuccess = (productosApiCreateProductoResponse200) & {
  headers: Headers;
};
;

export type productosApiCreateProductoResponse = (productosApiCreateProductoResponseSuccess)

export const getProductosApiCreateProductoUrl = () => {


  

  return `/api/productos/crear`
}

export const productosApiCreateProducto = async (productosApiCreateProductoBody: ProductosApiCreateProductoBody, options?: RequestInit): Promise<productosApiCreateProductoResponse> => {
    const formData = new FormData();
if(productosApiCreateProductoBody.imagen !== undefined) {
 formData.append(`imagen`, productosApiCreateProductoBody.imagen);
 }
formData.append(`data`, JSON.stringify(productosApiCreateProductoBody.data));

  const res = await fetch(getProductosApiCreateProductoUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiCreateProductoResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiCreateProductoResponse
}
  


/**
 * Endpoint para actualizar un producto existente. Requiere autenticaci칩n.
 * @summary Update Producto
 */
export type productosApiUpdateProductoResponse200 = {
  data: ProductoSchema
  status: 200
}

export type productosApiUpdateProductoResponseSuccess = (productosApiUpdateProductoResponse200) & {
  headers: Headers;
};
;

export type productosApiUpdateProductoResponse = (productosApiUpdateProductoResponseSuccess)

export const getProductosApiUpdateProductoUrl = (productoId: number,) => {


  

  return `/api/productos/actualizar/${productoId}`
}

export const productosApiUpdateProducto = async (productoId: number,
    productosApiUpdateProductoBody: ProductosApiUpdateProductoBody, options?: RequestInit): Promise<productosApiUpdateProductoResponse> => {
    const formData = new FormData();
if(productosApiUpdateProductoBody.imagen !== undefined) {
 formData.append(`imagen`, productosApiUpdateProductoBody.imagen);
 }
formData.append(`data`, JSON.stringify(productosApiUpdateProductoBody.data));

  const res = await fetch(getProductosApiUpdateProductoUrl(productoId),
  {      
    ...options,
    method: 'PATCH'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiUpdateProductoResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiUpdateProductoResponse
}
  


/**
 * Endpoint para eliminar un producto existente. Requiere autenticaci칩n.
 * @summary Delete Producto
 */
export type productosApiDeleteProductoResponse200 = {
  data: void
  status: 200
}

export type productosApiDeleteProductoResponseSuccess = (productosApiDeleteProductoResponse200) & {
  headers: Headers;
};
;

export type productosApiDeleteProductoResponse = (productosApiDeleteProductoResponseSuccess)

export const getProductosApiDeleteProductoUrl = (productoId: number,) => {


  

  return `/api/productos/eliminar/${productoId}`
}

export const productosApiDeleteProducto = async (productoId: number, options?: RequestInit): Promise<productosApiDeleteProductoResponse> => {
  
  const res = await fetch(getProductosApiDeleteProductoUrl(productoId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: productosApiDeleteProductoResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as productosApiDeleteProductoResponse
}
  


/**
 * @summary Login Usuario
 */
export type usuariosApiLoginUsuarioResponse200 = {
  data: TokenSchema
  status: 200
}

export type usuariosApiLoginUsuarioResponse400 = {
  data: DetailSchema
  status: 400
}

export type usuariosApiLoginUsuarioResponse404 = {
  data: DetailSchema
  status: 404
}

export type usuariosApiLoginUsuarioResponse500 = {
  data: DetailSchema
  status: 500
}

export type usuariosApiLoginUsuarioResponseSuccess = (usuariosApiLoginUsuarioResponse200) & {
  headers: Headers;
};
export type usuariosApiLoginUsuarioResponseError = (usuariosApiLoginUsuarioResponse400 | usuariosApiLoginUsuarioResponse404 | usuariosApiLoginUsuarioResponse500) & {
  headers: Headers;
};

export type usuariosApiLoginUsuarioResponse = (usuariosApiLoginUsuarioResponseSuccess | usuariosApiLoginUsuarioResponseError)

export const getUsuariosApiLoginUsuarioUrl = () => {


  

  return `/api/usuarios/login`
}

export const usuariosApiLoginUsuario = async (loginSchema: LoginSchema, options?: RequestInit): Promise<usuariosApiLoginUsuarioResponse> => {
  
  const res = await fetch(getUsuariosApiLoginUsuarioUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginSchema,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usuariosApiLoginUsuarioResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usuariosApiLoginUsuarioResponse
}
